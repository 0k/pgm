#!/bin/bash

## Protect against translations
export LC_ALL=C

##
## kal-shlib-common functions
##

print_exit() {
    echo $@
    exit 1
}

get_path() {
    local type

    type="$(type -t "$1")"
    case $type in
	("file")
	    type -p "$1"
	    return 0
	    ;;
	("function" | "builtin" )
	    echo "$1"
	    return 0
	    ;;
    esac
    return 1
}

depends() {

    ## Very important not to collide with variables that are created
    ## with depends.
    local __i __tr __path

    __tr=$(get_path "tr")
    test "$__tr" ||
	print_error "dependency check: couldn't find 'tr' command."

    for __i in $@ ; do

      if ! __path=$(get_path $__i); then
	  __new_name=$(echo $__i | "$__tr" '_' '-')
	  if [ "$__new_name" != "$__i" ]; then
	     depends "$__new_name"
	  else
	     print_error "dependency check: couldn't find '$__i' command."
	  fi
      else
	  if ! test -z "$__path" ; then
	      export "$(echo $__i | "$__tr" '-' '_')"=$__path
	  fi
      fi

    done
}

print_syntax_warning() {
    [ "$*" ] || print_syntax_error "$FUNCNAME: no arguments."
    [ "$exname" ] || print_syntax_error "$FUNCNAME: 'exname' var is null or not defined."
    echo "$exname: ${WARNING}script warning:${NORMAL} $@" >&2
}

print_error() {
    [ "$*" ] || print_syntax_warning "$FUNCNAME: no arguments."
    [ "$exname" ] || print_exit "$FUNCNAME: 'exname' var is null or not defined." >&2
    print_exit "$exname: ${ERROR}error:${NORMAL} $@" >&2
}

Wrap() {

    local quiet desc errlvl args

    quiet=false
    desc=""
    args=()
    while [ "$#" != 0 ]; do
        case "$1" in
            "-q") quiet="";;
            "-d") desc=$2; shift;;
            *) args=("${args[@]}" "$1");;
        esac
        shift
    done

    if test -z "${args[*]}"; then
        code=$(cat -)
        [ "$quiet" == false -a -z "$desc" ] &&
        print_error "no description for warp command"
    else
        code="${args[@]}"
        test -z "$desc" && desc="$code"
    fi
    [ "$quiet" ] && echo "$desc"

    output=$(echo "$code" | bash 2>&1 )
    errlvl="$?"
    if [ "$errlvl" == "0" ]; then
        return 0
    fi

    echo "${RED}Error in wrapped command:${NORMAL}"
    echo " ${DARKYELLOW}pwd:${NORMAL} $PWD"
    echo " ${DARKYELLOW}code:${NORMAL}"
    echo "$code" | sed -url1 "s/^/  ${GRAY}|${NORMAL}/g"
    echo " ${DARKYELLOW}output (${YELLOW}$errlvl${NORMAL})${DARKYELLOW}:${NORMAL}"
    echo "$output" | sed -url1 "s/^/  ${GRAY}|${NORMAL}/g"

    return $errlvl
}


## COLORS:

ansi_color() {
    if [ "$1" != "no" ]; then

        NORMAL=$(echo -en "\e[0m")
        RED=$(echo -en "\e[1;31m")
        GREEN=$(echo -en "\e[1;32m")
        DARKGREEN=$(echo -en "\e[0;32m")
        YELLOW=$(echo -en "\e[1;33m")
        DARKYELLOW=$(echo -en "\e[0;33m")
        BLUE=$(echo -en "\e[1;34m")
        GRAY=$(echo -en "\e[1;30m")
        WHITE=$(echo -en "\e[1;37m")
        CYAN=$(echo -en "\e[1;36m")
        PINK=$(echo -en "\e[1;35m")

        SUCCESS=$GREEN
        WARNING=$YELLOW
        FAILURE=$RED
        NOOP=$BLUE
        ON=$SUCCESS
        OFF=$FAILURE
        ERROR=$FAILURE

        ansi_color="yes"

    else

        NORMAL=
        RED=
        GREEN=
        DARKGREEN=
        YELLOW=
        DARKYELLOW=
        BLUE=
        GRAY=
        WHITE=

        SUCCESS=
        WARNING=
        FAILURE=
        NOOP=
        ON=
        OFF=
        ERROR=

        ansi_color="no"

    fi
}

warn() { echo "${YELLOW}Warning:$NORMAL" "$@" >&2 ; }
info() { echo "${BLUE}II$NORMAL" "$@" >&2 ; }
verb() { [ "$VERBOSE" ] && echo "$@" >&2 ; }
err() { echo "${RED}Error:$NORMAL" "$@" >&2 ; }
die() { err "$@" ; exit 1; }

print_usage() {
    local act

    if [ "$action" ] && valid_action "$action"; then
        export action_${action}_help >/dev/null 2>&1
        export action_${action}_usage >/dev/null 2>&1
        export action_${action}_options >/dev/null 2>&1
        echo "$(eval echo "\"\$action_${action}_help\"")"
        echo
        echo "usage:"
        echo "  $exname $action $(eval echo "\$action_${action}_usage")"
        echo
        echo "options:"
        echo "$(eval echo "\"\$action_${action}_options\"")" | sed -r 's/^/  /g'
    else
        echo "usage:"
        for act in $actions; do
            export action_$act_usage >/dev/null 2>&1
            echo "  $exname $act $(eval echo \$action_${act}_usage)"
        done
    fi >&2

}

##
## Common
##

pg_local_opts=${pg_local_opts:-""}
prefix_pg_local_command=${prefix_pg_local_command:-"sudo -u postgres"}

[ -f ~/.pgm.rc ] && . ~/.pgm.rc

export pg_local_opts prefix_pg_local_command

get_path() { (
    IFS=:
    for d in $PATH; do
        filename="$d/$1"
        if test -x "$filename"; then echo "$d/$1"; return 0; fi
    done
    return 1
) }


host_psql() {
    host="$1"
    shift
    rexec "$host" '$prefix_pg_local_command psql $pg_local_opts' "$@"
}

## To be piped in it
sql() {
    host="$1"
    shift
    {
        [ "$IGNORE_ERRORS" ] || echo "\set ON_ERROR_STOP on"
        cat -
    } | host_psql "$host" -qAt "$@"
}
export -f sql

## To be piped in it
rexec() {
    local host
    host="$1"
    shift
    code="
    [ -d \"$BACKUPS\" ] && cd \"$BACKUPS\" || cd /;
    pg_local_opts=\${pg_local_opts:-}
    prefix_pg_local_command=\${prefix_pg_local_command:-sudo -u postgres}
    [ -e \"~/.pgm.rc\" ] && . \"~/.pgm.rc\"
    export pg_local_opts prefix_pg_local_command
    $(
        if [ "$*" ]; then
            echo "$*"
        else
            cat
        fi
    )"

    if [ -z "$host" ]; then
        bash -c "$code"
    else
        ssh-once "$host" -- "$code"
    fi
}
export -f rexec


db_exists() {
    local host db
    host="$1"
    db="$2"

    read result < <(
        echo " SELECT COUNT(*)
            FROM pg_database
            WHERE datistemplate = false AND datname = '$db' " |
        sql "$host" "postgres"
    )
    test "$result" == 1
}

file_exists() {
    local host file
    host="$1"
    file="$2"

    echo "[ -e '$file' ]" | rexec "$host"
}

host_rename() {
    local host file
    host="$1"
    file="$2"

    cat <<EOF | rexec "$host"

    name="$2"
    dirname=\$(dirname \$name)
    basename=\$(basename \$name)
    first_part=\$(echo "\$basename" | cut -f 1 -d ".")
    end_part=\$(echo "\$basename" | cut -f 2- -d ".")

    i=1
    new_name="\$dirname/\${first_part}-\$i.\${end_part}"
    while [ -e "\$new_name" ]; do
        i=\$[\$i + 1]
        new_name="\$dirname/\${first_part}-\$i.\${end_part}"
    done

    mv -v "\$name" "\$new_name"
EOF

}

file_or_db_exists() {
    local host file db
    host="$1"
    file="$2"
    db="$3"

    if [ "$file" ]; then
        file_exists "$host" "$file"
    else
        db_exists "$host" "$db"
    fi
}

host_pg_drop() {
    host="$1"
    db="$2"

    host_pg_drop_session "$host" "$db"

    [ "$VERBOSE" ] && echo "Dropping database '$db' on" \
        "$([ "$host" ] && echo "host '$host'" || echo "localhost")..."

    echo "DROP DATABASE $2;" |
    sql "$host" "postgres" >/dev/null

    errlvl="$?"
    if [ "$VERBOSE" ]; then
        echo -n "     ... "
        [ "$errlvl" == 0 ] && echo "ok" || echo "failed!"
    fi
    return $errlvl

}

host_pg_drop_session() {
    local host db

    host="$1"
    db="$2"
    if version_gt "$(host_version "$host")" 9.2.0; then
        echo "SELECT pg_terminate_backend(pid)
          FROM pg_stat_activity
          WHERE pid <> pg_backend_pid() AND datname = '$db';"
    else
        echo "SELECT pg_terminate_backend(procpid)
          FROM pg_stat_activity
          WHERE procpid <> pg_backend_pid() AND datname = '$db';"
    fi | sql "$host" "postgres" >/dev/null

}


BACKUPS=/var/backups/pg
host_pg_save() {
    local host db label

    host="$1"
    db="$2"
    label="$3"

    postfix="$(date +%FT%T | tr ":" "-")"
    if [ "$label" ]; then
        archive=${db}_${postfix}_$label.sql.bz2
    else
        archive=${db}_$postfix.sql.bz2
    fi
    echo "Saving to '$BACKUPS/$archive' on" \
        $([ "$host" ] && echo "host '$host'." || echo "localhost.") \

    _host_pg_save "$host" "$db" "$BACKUPS/$archive"
}


_host_pg_save() {
    host="$1"
    db="$2"
    archive="$3"
    rexec "$host" "\
            \$prefix_pg_local_command pg_dump \$pg_local_opts -Ox \"$db\" |
            bzip2 > \"$archive\"
            pipe_errlvl=\"\\${PIPESTATUS[0]}\" errlvl=\"\$?\"
            if [ \"\$errlvl\" != 0 -o \"\$pipe_errlvl\" != 0 ]; then
                rm -vf \"$BACKUPS/$archive\"
                exit 1
            fi
        "
}

host_stream_from_file() {
    local host filename pipe
    host="$1"
    filename="$2"
    pipe="$3"
    rexec "$host" "

filename=\"$filename\"
uncompress() {
    local ft
    ft=\$(file \"\$filename\")
    if echo \"\$ft\" | grep \"bzip2 compressed\" > /dev/null 2>&1; then
       bunzip2
    elif echo \"\$ft\" | grep \"gzip compressed\" > /dev/null 2>&1; then
       gunzip
    else
       cat
    fi
}
cat \"\$filename\" | uncompress | $pipe
"
}

host_stream_to_file() {
    local host filename pipe
    host="$1"
    filename="$2"
    pipe="$3"

    rexec "$host" "
filename=\"$filename\"
compress() {
    if [[ \"\$filename\" == *\".bz2\" ]]; then
       bzip2
    elif [[ \"\$filename\" == *\".gz\" ]]; then
       gzip
    else
       echo 'Warning: unknown extension, outputing to RAW sql.' >&2
       cat
    fi
}
$pipe | compress > \"\$filename\"
"
}

stream_from_file_or_database() {
    local host file db pipe
    host="$1"
    file="$2"
    db="$3"
    pipe="$4"
    if [ "$file" ]; then
        host_stream_from_file "$host" "$file" "$pipe"
    else
        host_pg_dump "$host" "$db" "$pipe"
    fi
}

stream_to_file_or_database() {
    local host file db pipe
    host="$1"
    file="$2"
    db="$3"
    pipe="$4"

    if [ "$file" ]; then
        host_stream_to_file "$host" "$file" "$pipe"
    else
        host_pg_fill "$host" "$db" "$pipe"
    fi
}

host_pg_dump() {
    host="$1"
    db="$2"
    pipe="$3"

    if [ -z "$host" ]; then
        $prefix_pg_local_command pg_dump -Ox $pg_local_opts "$db" | $pipe
    else
        ssh-once "$host" -- \
            "cd / ;
             \$prefix_pg_local_command pg_dump \$pg_local_opts -Ox '$db' |
             $pipe
             "
    fi
}

host_pg_fill() {
    host="$1"
    db="$2"
    pipe="$3"

    export -f err
    export -f warn

    rexec "$host" "

        warn() { echo \"${YELLOW}Warning:$NORMAL\" \"\$@\" >&2 ; }
        info() { echo \"${BLUE}II$NORMAL\" \"\$@\" >&2 ; }
        verb() { [ \"$VERBOSE\" ] && echo \"\$@\" >&2 ; }
        err() { echo \"${RED}Error:$NORMAL\" \"\$@\" >&2 ; }
        die() { err \"\$@\" ; exit 1; }

        output=\$(
        (sleep 0.1; pv -i 0.2 -cN received) | buffer -m 8M |
        $pipe |
        (sleep 0.3; pv -i 0.2 -cN unpacked) | buffer -m 8M |
        (sleep 0.5; pv -fi 0.2 -cN fill) |
        (echo '\\set ON_ERROR_STOP on'; cat) |
          \$prefix_pg_local_command psql \$pg_local_opts \"$db\" 2>&1 >/dev/null
         )
        errlvl=\"\$?\"
        if [ \"\$errlvl\" == "0" -a -z \"\$output\" ]; then
            exit 0
        else
            if [ \"\$errlvl\" != 0 ]; then
                err 'There was some errors while filling database:'
                echo \"\$output\"
                exit 1
            else
                warn 'There was some message while filling database:'
                echo \"\$output\"
                exit 0
            fi
        fi
"

}

host_get_owner() {
    host="$1"
    db="$2"
    echo "SELECT rolname
        FROM pg_database pd
        JOIN pg_authid ON pd.datdba = pg_authid.oid
        WHERE datistemplate = false AND datname = '$db'" |
        sql "$host" "$db"
}

host_pg_chown() {

    local host user db

    host="$1"
    user="$2"
    db="$3"

    [ "$VERBOSE" ] && wrap_opts="" || wrap_opts="-q"
    Wrap $wrap_opts -d "Setting ownership on views" <<EOF || exit 1

       echo "SELECT 'ALTER TABLE ' || viewname || ' OWNER TO $user;'
         FROM pg_views
         WHERE schemaname = 'public'" |
       sql "$host" "$db" | sql "$host" "$db"
EOF

    Wrap $wrap_opts -d "Setting ownership on tables" <<EOF || exit 1
       echo "SELECT 'ALTER TABLE ' || tablename || ' OWNER TO $user;'
          FROM pg_tables
          WHERE schemaname = 'public'" |
       sql "$host" "$db" | sql "$host" "$db"
EOF

    Wrap $wrap_opts -d "Restating user permissions on tables" <<EOF || exit 1
       echo "SELECT 'GRANT SELECT, INSERT, UPDATE, DELETE ON ' ||
                 tablename || ' TO $user;'
          FROM pg_tables
          WHERE schemaname = 'public'" |
       sql "$host" "$db" | sql "$host" "$db"
EOF

    Wrap $wrap_opts -d "Setting ownership on sequences" <<EOF || exit 1
       echo "SELECT 'ALTER TABLE ' || sequence_name || ' OWNER TO $user;'
          FROM information_schema.sequences
          WHERE sequence_schema = 'public'" |
       sql "$host" "$db" | sql "$host" "$db"
EOF

    Wrap $wrap_opts -d "Setting ownership on database $db" <<EOF || exit 1
       echo "ALTER DATABASE $db OWNER TO $user;" |
       sql "$host" "$db"
EOF

}

user_exists() {
    host="$1"
    user="$2"

    [ "$(echo "SELECT 1 FROM pg_roles WHERE rolname='$user'" |
         sql "$host" "postgres")" ]
}

host_create_user() {
    host="$1"
    user="$2"

    [ "$VERBOSE" ] && wrap_opts="" || wrap_opts="-q"
    Wrap $wrap_opts -d "Creating user $user" <<EOF || exit 1
    echo "CREATE USER $user" | sql "$host" "postgres"
EOF

}

host_createdb() {
    host="$1"
    owner="$2"
    db="$3"

    [ "$VERBOSE" ] && echo "Creating database '$db' on" \
        "$([ "$host" ] && echo "host '$host'" || echo "localhost")..."

    if [ -z "$host" ]; then
        $prefix_pg_local_command createdb $pg_local_opts -O "$owner" "$db"
    else
        ssh-once "$host" -- \
            "cd / ; \$prefix_pg_local_command createdb \$pg_local_opts -O '$owner' '$db'"
    fi
    errlvl="$?"
    if [ "$VERBOSE" ]; then
        echo -n "     ... "
        [ "$errlvl" == 0 ] && echo "ok" || echo "failed!"
    fi
    return $errlvl
}

host_list_db() {
    host="$1"
    dbpattern="${2/\*/%}"
    dbpattern="${dbpattern:-%}"
    user=${3:-%%}

    ## XXXvlab: lots of possibilities for sql injection, but hum, anyway
    ## we are already superuser of postgres, so... well...
    echo "
        SELECT datname AS database,
               rolname AS user,
               pg_size_pretty(pg_database_size(pd.datname)) AS size,
               'database' AS type
        FROM pg_database pd
        JOIN pg_authid ON pd.datdba = pg_authid.oid
        WHERE datistemplate = false AND
              rolname LIKE '$user' AND
              datname LIKE '$dbpattern'
        ORDER BY pd.datname" | sql "$host" "postgres"

}

host_list_file() {
    host="$1"
    fpattern="$2"

    if [[ "$fpattern" == "/*" ]]; then  ## absolute filepattern
        base_dir="/"
    else
        base_dir="$BACKUPS"
    fi

    ## XXXvlab: lots of possibilities for script injection, but hum, anyway
    ## we are already user postgres or equivalent, so... well...

    cat <<EOF | rexec "$host" | sed -r 's%^\./%%g' | sed -r 's%(\|[0-9.]+)M%\1 MB%g;s%(\|[0-9.]+)K%\1 kB%g;s%(\|[0-9.]+)$%\1  B%g'
    [ -d "$base_dir" ] || exit 1
    cd "$base_dir"
    if [ -d "$fpattern" ]; then
       fpattern="$fpattern/*"
    else
       fpattern="$fpattern"
    fi
    ls -hl \$fpattern | awk '{print \$9 "|-|" \$5 "|file"}'

EOF

}

parse_dbpattern() {

    python -c '
import re
import sys

PATTERN = (r"^((?P<host>([^@]+@)?[a-zA-Z0-9.-]+):)?"
           r"("  ## database ?
           r"((?P<pguser>[a-zA-Z0-9_]+)@)?"
           r"(?P<dbpattern>[a-zA-Z0-9_*]*)"
           r"(:(?P<port>[0-9*]+))?"
           r"|"  ## or file pattern ?
           r"(?P<fpath>.*)"
           r")$"
       )

def parse_db_pattern(p):
    p = p or ""
    match = re.search(PATTERN, p)
    if not match:
        exit(1)
    return match.groupdict()

parsed = parse_db_pattern("'$1'")

## The last value '1' is there to check the parsing was ok

sys.stdout.write("\0".join([parsed[k] if parsed[k] else ""
                for k in ("host", "pguser", "dbpattern", "port", "fpath")] +
                           ["1", ]))
'

}

read-0() {
    while [ "$1" ] && IFS=$'\0' read -r -d '' "$1"; do
        shift
    done
}

read_dbpattern() {
    local dbpattern check
    dbpattern="$1"
    vhost="$2"
    vuser="$3"
    vdb="$4"
    vport="$5"
    vpath="$6"

    read-0 "$vhost" "$vuser" "$vdb" "$vport" "$vpath" check < <(parse_dbpattern "$dbpattern")

    if [ "$check" != "1" ]; then
        die "Pattern $dbpattern is not valid. Please try [[USER@]HOST:][PGUSER@][DBPATTERN][:PGPORT] or [[USER@]HOST:][FILEPATTERN]."
    fi
}

export master_pid=$$
ssh-once() {
    ssh -o ControlPath=/tmp/ssh-control-master-${master_pid} \
        -o ControlMaster=auto -o ControlPersist=900 \
        "$@"
}

ssh-quit() {
    ssh-once -O exit "$@"
}

depends() {
   missing=""
   for cmd in "$@"; do
       get_path "$cmd" >/dev/null || missing="$missing $cmd"
   done
   test "$missing" == "" || die "Missing dependencies:$missing"
}

host_version() {
    host="$1"
    echo "SHOW server_version" | sql "$host" "postgres"
}

check_host() {
    host="$1"

    dependencies="pv buffer file"

    if [ "$host" ]; then
        ssh-once "$host" true || die "Couldn't reach host $host"
        ssh-once "$host" '

die() { echo $*; exit 1 ; }

get_path() { (
    IFS=:
    for d in $PATH; do
        filename="$d/$1"
        if test -x "$filename"; then echo "$d/$1"; return 0; fi
    done
    return 1
) }

depends() {
   missing=""
   for cmd in "$@"; do
       get_path "$cmd" >/dev/null || missing="$missing $cmd"
   done
   test "$missing" == "" || die "Missing dependencies on '"$host"':$missing"
}

depends '"$dependencies" || exit 1
    else
        depends $dependencies
    fi

    if ! echo "SELECT 1;" | sql "$host" "postgres" >/dev/null; then
        die "Insufficient access: psql command non-working."
    fi

    if ! echo "SHOW is_superuser;" | sql "$host" "postgres" >/dev/null; then
        die "Insufficient postgres permission on" \
            $([ "$host" ] && echo "host '$host'." || echo "localhost.")
    fi

}

function version_gt() { test "$(echo "$@" | tr " " "\n" | sort -V | tail -n 1)" == "$1"; }

get_active_connection_nb() {
    host="$1"
    src="$2"
    if version_gt "$(host_version "$host")" 9.2.0; then
        echo "SELECT COUNT(DISTINCT pid) AS count
                FROM pg_stat_activity
                WHERE datname = '$src'
                  AND pid <> pg_backend_pid()"
    else
        echo "SELECT COUNT(DISTINCT procpid) AS count
                FROM pg_stat_activity
                WHERE datname = '$src'
                  AND procpid <> pg_backend_pid()"
    fi | sql "$host" "postgres"
}

filter_role_instructions() {
    egrep -v "^ALTER (TABLE|SCHEMA) [a-zA-Z0-9._-]+ OWNER TO \"?.*\"?;$" |
    egrep -v "^(GRANT|REVOKE) (ALL|SELECT) ON TABLE [a-zA-Z0-9._-]+ (FROM|TO) \"?.*\"?;$"
}

## These are used in subprocess
export -f host_psql
export -f ssh-once

##
## Actions
##

action_cp_usage="[-q] [-f | -b] SRC_DBNAME DST_DBNAME"
action_cp_help="Copy database SRC to DST database"
action_cp_options="\
-q       Use quicker templating system to make the copy, note that
         all active session will be dropped.
-f       Force copy even if DST_DBNAME already exists (it'll overwrite it).
-b       As 'force' but will backup the database before overwriting it.
"

action_cp () {

    cmdline=("$@")

    quick=""
    force=""
    backup=""
    while [ "$#" != 0 ]; do
        case "$1" in
            "-q") quick="true";;
            "-b") backup="true";;
            "-f") force="true";;
            -*)
                err "No options $1."
                print_usage
                exit 1
                ;;
            "")
                err "Invalid '$1' argument."
                print_usage
                exit 1
                ;;
            *)
                if [ -z "$src" ]; then src="$1"
                elif [ -z "$dst" ]; then dst="$1"
                else
                    echo "Too much arguments..."
                    print_usage
                    exit 1
                fi
                ;;
        esac
        shift
    done

    if [ -z "$src" -o -z "$dst" ]; then
        echo "Missing argument"
        print_usage
        exit 1
    fi

    ##
    ## Code
    ##

    read_dbpattern "$src" shost suser sdb sport sfile
    read_dbpattern "$dst" dhost duser ddb dport dfile

    [ "$sport" -o "$dport" ] && die "No support yet for specifying ports"
    [ "$suser" ] && die "No support for specifying owner in source database."

    check_host "$shost"
    check_host "$dhost"

    if [ "$sfile" -o "$dfile" ]; then
        if [ "$quick" ]; then
            die "You can use quick copy only if source and destination are both database."
        fi
    fi

    if [ -z "$sfile" -a -z "$dfile" -a "$shost" != "$dhost" ]; then
        if [ "$quick" ]; then
            die "You can't use quick copy option on different hosts."
        fi

        sversion="$(host_version "$shost")"
        dversion="$(host_version "$dhost")"

        if [ "$sversion" != "$dversion" ]; then
            warn "Postgres version mismatch between hosts" \
                "(src: $sversion, dst: $dversion). This might generate errors !"
        fi
    fi

    if [ -z "$sfile" -a -z "$dfile" -a "$shost" == "$dhost" -a "$sdb" == "$ddb" ]; then
        die "You can't copy the database on itself"
    fi

    if [ "$sfile" -a "$shost" == "$dhost" -a "$sfile" == "$dfile" ]; then
        die "You can't copy files on itself"
    fi

    if [ "$shost" == "$dhost" -a "$shost" ]; then
        echo "Delegating command to $shost."
        ssh "$shost" "$exname $action$(echo " ${cmdline[@]}" | sed -r "s/ $shost:/ /g")"
        exit $?
    fi

    if ! file_or_db_exists "$shost" "$sfile" "$sdb"; then
        die "Source file or database '$sdb$sfile' not found on" \
            $([ "$shost" ] && echo "host '$shost'." || echo "localhost.")
    fi

    if [ -z "$dfile" ]; then
        ## getting final owner (usefull only if destination is a database)
        if [ "$duser" ]; then  ## owner was specified
            owner=$duser
        else  ## Let's take the current owner of the source if possible
            if [ -z "$sfile" ]; then
                owner=$(host_get_owner "$shost" "$sdb") || die "Couldn't get owner of $src"
            else
                die "Please specify a destination database owner."
            fi
        fi
    fi

    if file_or_db_exists "$dhost" "$dfile" "$ddb"; then
        if [ -z "$force" -a -z "$backup" ]; then
            if [ "$dfile" ]; then
                die "Destination file '$dfile' already exists on" \
                    "$([ "$dhost" ] && echo "host '$dhost'." || echo "localhost.")" \
                    "Use '-f' or '-b' if you want to overwrite it, or rename it."
            else
                die "Destination database '$ddb' already exists on" \
                    "$([ "$dhost" ] && echo "host '$dhost'." || echo "localhost.")" \
                    "Use '-f' or '-b' if you want to overwrite it, or archive it."
            fi
        else
            if [ "$backup" ]; then
                if [ "$dfile" ]; then
                    host_rename "$dhost" "$dfile" || die "Couldn't rename $dfile on" \
                        "$([ "$dhost" ] && echo "host '$dhost'." || echo "localhost.")"
                else
                    host_pg_save "$dhost" "$ddb" || die "Couldn't archive $ddb on" \
                        "$([ "$dhost" ] && echo "host '$dhost'." || echo "localhost.")"
                fi
            fi
            if [ "$dfile" ]; then
                ## file will be overritten by copy command.
                :
            else
                host_pg_drop "$dhost" "$ddb" ||
                die "Couldn't drop database $ddb on" \
                    "$([ "$dhost" ] && echo "host '$dhost'." || echo "localhost.")"
            fi
        fi
    fi


    if [ -z "$sfile" -a -z "$dfile" -a -z "$shost" -a -z "$dhost" ]; then
        connections=$(get_active_connection_nb "$shost" "$src")
        [ "$connections" == "0" ] && quick=true
    else
        quick=""
    fi

    drop_dst_db() {
        stty echo
        if [ "$to_drop" ]; then
            echo "Dropping partial database $dst."
            host_pg_drop "$dhost" "$ddb"
        fi
    }

    if [ "$quick" ]; then
        echo -n "Quick copy of $src to $dst. "
        if [ "$connections" -gt "0" ]; then
            echo "Cutting down $connections connections."
            host_pg_drop_session "$shost" "$sdb"
        fi

        $prefix_pg_local_command createdb $pg_local_opts -O openerp "$ddb" -T "$sdb" ||
        die "createdb failed!"
        exit 0

    else

        if [ -z "$dfile" ]; then
            to_drop=yes
            host_createdb "$dhost" "$owner" "$ddb" || die "createdb failed!"
            trap drop_dst_db EXIT
        fi

        echo "Copy of $src to $dst."
        stream_from_file_or_database "$shost" "$sfile" "$sdb" "$(
        [ -z "$shost" -a -z "$dhost" ] && echo "cat" || echo "bzip2 -3")" |
        filter_role_instructions |
        stream_to_file_or_database "$dhost" "$dfile" "$ddb" "$(
        [ -z "$shost" -a -z "$dhost" ] && echo "cat" || echo "bunzip2")" ||
        die "Copy failed !"
        echo "Finished copy successfully."
        to_drop=
        if [ "$duser" ]; then
            echo "Chowning $ddb on" \
                "$([ "$dhost" ] && echo "host '$dhost'" || echo "localhost")" \
                "to user $duser."
            host_pg_chown "$dhost" "$duser" "$ddb" || die "Chown to $duser failed."
        fi
    fi


}


action_rm_usage="[-f] [-b] DBNAME"
action_rm_help="Drop database DBNAME"
action_rm_options="\
-f       Force drop even if there are active session opened.
-b       Make backup of database(s) before dropping it.
"

action_rm () {

    depends psql

    cmdline=("$@")

    target=""
    force=""
    backup=""
    while [ "$#" != 0 ]; do
        case "$1" in
            "-b") backup="true";;
            "-f") force="true";;
            -*)
                err "No options $1."
                print_usage
                exit 1
                ;;
            "")
                err "Invalid '$1' argument."
                print_usage
                exit 1
                ;;
            *)
                if [ -z "$target" ]; then target="$1"
                else
                    echo "Too much arguments..."
                    print_usage
                    exit 1
                fi
                ;;
        esac
        shift
    done

    if [ -z "$target" ]; then
        err "Missing argument"
        print_usage
        exit 1
    fi

    ##
    ## Code
    ##

    read_dbpattern "$target" host user db port file

    [ "$port" -o "$port" ] && die "No support yet for specifying ports"
    [ "$suser" ] && die "You don't need to specify owner in database you remove."
    [ "$file" ] && die "No support yet for deleting file"

    check_host "$host"

    if ! db_exists "$host" "$db"; then
        die "Target database '$db' doesn't exists on" \
            $([ "$host" ] && echo "host '$host'." || echo "localhost.")
    fi

    connections=$(get_active_connection_nb "$host" "$db")

    if [ "$backup" ]; then
        host_pg_save "$host" "$db" || die "Couldn't archive $db on" \
            "$([ "$host" ] && echo "host '$host'." || echo "localhost.")"
    fi

    if ! [ "$connections" = "0" ]; then
        if [ "$force" ]; then
            warn "Closing $connections active connections to $target."
            host_pg_drop_session "$host" "$db"
        else
            die "There are $connections active connections to $target. (Use -f to close them.)"
        fi
    fi

    echo "Dropping database '$target'." &&
    host_pg_drop "$host" "$db" || die "Dropping $target failed."

}


action_kill_usage="[-v] DBNAME"
action_kill_help="Kill all active connection to the target DBNAME"
action_kill_options="\
-v       Verbose mode on.
"

action_kill () {

    depends psql

    cmdline=("$@")

    target=""
    VERBOSE=${VERBOSE:-}
    while [ "$#" != 0 ]; do
        case "$1" in
            "-v") VERBOSE="true";;
            -*)
                err "No options $1."
                print_usage
                exit 1
                ;;
            "")
                err "Invalid '$1' argument."
                print_usage
                exit 1
                ;;
            *)
                if [ -z "$target" ]; then target="$1"
                else
                    echo "Too much arguments..."
                    print_usage
                    exit 1
                fi
                ;;
        esac
        shift
    done

    if [ -z "$target" ]; then
        err "Missing argument"
        print_usage
        exit 1
    fi

    ##
    ## Code
    ##

    read_dbpattern "$target" host user db port file

    [ "$port" -o "$port" ] && die "No support yet for specifying ports"
    # [ "$user" ] && die "You don't need to specify owner in database you'll kill."
    [ "$file" ] && die "You can't kill a file !."

    check_host "$host"

    if ! db_exists "$host" "$db"; then
        die "Target database '$db' doesn't exists on" \
            $([ "$host" ] && echo "host '$host'." || echo "localhost.")
    fi


    if [ "$VERBOSE" ]; then
        ## additional information in verbose mode
        connections=$(get_active_connection_nb "$host" "$db")
        if ! [ "$connections" = "0" ]; then
            verb "Closing $connections active connections to $target."
            host_pg_drop_session "$host" "$db"
        else
            verb "There are no active connections to kill."
        fi
    else
        host_pg_drop_session "$host" "$db"
    fi

}


action_chown_usage="[-v] USER DBNAME"
action_chown_help="Change owner of DBNAME to USER"
action_chown_options="\
-v       Verbose mode on.
"

action_chown () {

    cmdline=("$@")

    owner=""
    target=""
    force=""
    VERBOSE=${VERBOSE:-}
    while [ "$#" != 0 ]; do
        case "$1" in
            "-v") VERBOSE="true";;
            "-f") force="true";;
            -*)
                err "No options $1."
                print_usage
                exit 1
                ;;
            "")
                err "Invalid '$1' argument."
                print_usage
                exit 1
                ;;
            *)
                if [ -z "$owner" ]; then owner="$1"
                elif [ -z "$target" ]; then target="$1"
                else
                    echo "Too much arguments..."
                    print_usage
                    exit 1
                fi
                ;;
        esac
        shift
    done

    if [ -z "$target" -o -z "$owner" ]; then
        err "Missing argument"
        print_usage
        exit 1
    fi

    ##
    ## Code
    ##

    read_dbpattern "$target" host user db port file

    [ "$port" -o "$port" ] && die "No support yet for specifying ports"
    [ "$user" ] && die "You don't need to specify owner on target database" \
        "you'll chown."
    [ "$file" ] && die "You can't change ownership of a non-database."

    check_host "$host"

    if ! db_exists "$host" "$db"; then
        die "Target database '$db' doesn't exists on" \
            $([ "$host" ] && echo "host '$host'." || echo "localhost.")
    fi

    if ! user_exists "$host" "$owner"; then
        if [ "$force" ]; then
            host_create_user "$host" "$owner"
        else
            die "No postgres user '$owner' on" \
                $([ "$host" ] && echo "host '$host'." || echo "localhost.") \
                "Use '-f' option to force creation of the user."
        fi
    fi

    host_pg_chown "$host" "$owner" "$db"

}


action_save_usage="[-v] DBNAME [LABEL]"
action_save_help="Make a backup of the current database in $BACKUPS"
action_save_options="\
-v       Verbose mode on.
"

action_save () {

    cmdline=("$@")

    label=""
    target=""
    force=""
    VERBOSE=${VERBOSE:-}
    while [ "$#" != 0 ]; do
        case "$1" in
            "-v") VERBOSE="true";;
            "-f") force="true";;
            -*)
                err "No options $1."
                print_usage
                exit 1
                ;;
            "")
                err "Invalid '$1' argument."
                print_usage
                exit 1
                ;;
            *)
                if [ -z "$target" ]; then target="$1"
                elif [ -z "$label" ]; then label="$1"
                else
                    echo "Too much arguments..."
                    print_usage
                    exit 1
                fi
                ;;
        esac
        shift
    done

    if [ -z "$target" ]; then
        err "Missing argument"
        print_usage
        exit 1
    fi

    ##
    ## Code
    ##

    read_dbpattern "$target" host user db port file

    [ "$port" -o "$port" ] && die "No support yet for specifying ports"
    [ "$user" ] && die "You don't need to specify owner on target database" \
        "you'll save."
    [ "$file" ] && die "You can't save a non-database."


    check_host "$host"

    if ! db_exists "$host" "$db"; then
        die "Target database '$db' doesn't exists on" \
            $([ "$host" ] && echo "host '$host'." || echo "localhost.")
    fi

    host_pg_save "$host" "$db" "$label"

}


action_ls_usage="[-s] [-c] [DBPATTERN]"
action_ls_help="List databases according to pattern"
action_ls_options="
-s       Print only the database name.
-c       Show number of active connection to the database.
"

action_ls () {

    cmdline=("$@")

    short=""
    target=""
    show_connections=""
    while [ "$#" != 0 ]; do
        case "$1" in
            "-s") short="true";;
            "-c") show_connections="true";;
            -*)
                err "No options $1."
                print_usage
                exit 1
                ;;
            "")
                err "Invalid '$1' argument."
                print_usage
                exit 1
                ;;
            *)
                if [ -z "$target" ]; then target="$1"
                else
                    echo "Too much arguments..."
                    print_usage
                    exit 1
                fi
                ;;
        esac
        shift
    done

    ##
    ## Code
    ##

    read_dbpattern "$target" host user db port fpattern

    [ "$port" ] && die "No support yet for specifying ports"

    check_host "$host"

    if [ -z "$db" -a "$fpattern" ]; then
        dbs=$(host_list_file "$host" "$fpattern");
    else
        dbs=$(host_list_db "$host" "$db" "$user")
    fi ||

    die "Couldn't retrieve database list."

    echo "$dbs" | while IFS=$'|' read -r database pguser size type; do
        if [ "$short" ]; then
            echo "$database"
        elif [ "$show_connections" ]; then
            ## Could be much quicker if done in the postgres side.
            if [ "$type" == "database" ]; then
                conn=$(get_active_connection_nb "$host" "$database")
            else
                conn="-"
            fi
            printf "%-50s ${CYAN}%-15s${NORMAL} ${DARKYELLOW}%10s${NORMAL} %10s\n" \
                 "$database" "$pguser" "$size" "$conn"
        else
            printf "%-50s ${CYAN}%-15s${NORMAL} ${DARKYELLOW}%10s${NORMAL}\n" \
                "$database" "$pguser" "$size"
        fi
    done

}



##
## Code
##


exname=$(basename $0)

## XXXvlab: all commands don't depend on all this strictly speaking.
depends buffer pv grep sed psql

ansi_color "$ansi_color"

actions="$(set | grep -E "^action_[a-zA-Z0-9_]+ ()" | cut -f 1 -d " " | cut -f 2- -d "_")"

valid_action() {
    echo "$actions" | grep "^$1" >/dev/null;
}

parse_generic_options() {
    ## stores in 'action' the first non optional word of the command line
    ## and stores in 'command' array all the other commands
    ## additionally will take care of '--help' argument for all sub commands.
    command=()
    while [ "$#" != 0 ]; do
        case "$1" in
            --help)
                print_usage
                exit 0
                ;;
            -*)
                command=("${command[@]}" "$1")
                ;;
            *)
                ## ignore
                if [ -z "$action" ]; then action="$1"
                else
                    command=("${command[@]}" "$1")
                fi
                :
                ;;
        esac
        shift
    done
}

parse_generic_options "$@"

if test -z "$action" || ! valid_action "$action"; then
    [ "$action" ] && echo "Invalid action '$action'." >&2
    print_usage
    exit 1
fi


## complete name
action=$(echo "$actions"  | grep "^$action")

"action_$action" "${command[@]}"
